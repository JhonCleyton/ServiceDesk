{% extends 'base.html' %}
{% block title %}Sala de Espera{% endblock %}
{% block content %}
<h2>Sala de Espera</h2>
<div class="row g-3">
  <div class="col-lg-8">
    <ul class="nav nav-tabs" id="gameTabs" role="tablist">
      <li class="nav-item" role="presentation">
        <button class="nav-link active" id="snake-tab" data-bs-toggle="tab" data-bs-target="#snake" type="button" role="tab">Snake</button>
      </li>
      <li class="nav-item" role="presentation">
        <button class="nav-link" id="sudoku-tab" data-bs-toggle="tab" data-bs-target="#sudoku" type="button" role="tab">Sudoku</button>
      </li>
    </ul>
    <div class="tab-content border border-top-0 rounded-bottom p-3" id="gameTabsContent">
      <div class="tab-pane fade show active" id="snake" role="tabpanel">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="d-flex align-items-center gap-2">
            <span class="badge text-bg-secondary">Pontua√ß√£o: <span id="snakeScore">0</span></span>
            <span class="badge text-bg-info">Velocidade: <span id="snakeSpeed">1x</span></span>
          </div>
          <div class="d-flex gap-2">
            <button class="btn btn-sm btn-primary" id="snakeStart">Iniciar</button>
            <button class="btn btn-sm btn-outline-secondary" id="snakeReset">Reset</button>
          </div>
        </div>
        <div class="position-relative" style="max-width: 480px;">
          <div class="ratio ratio-1x1 rounded border shadow-sm" style="background: radial-gradient(120% 120% at 10% 10%, #0b132b 0%, #0a0f1e 60%, #070b14 100%);">
            <canvas id="snakeCanvas" tabindex="0" style="outline:none; border-radius:.5rem"></canvas>
          </div>
          <div id="snakeOverlay" class="position-absolute top-0 start-0 w-100 h-100 d-flex flex-column justify-content-center align-items-center bg-dark bg-opacity-75 text-white rounded d-none" style="backdrop-filter: blur(2px);">
            <div class="fs-4 mb-2" id="snakeMsg">Fim de jogo</div>
            <div class="mb-3">Pontua√ß√£o: <span id="snakeFinal">0</span></div>
            <button class="btn btn-primary" id="snakeAgain"><i class="bi bi-arrow-counterclockwise me-1"></i>Jogar novamente</button>
          </div>
        </div>
      </div>
      <div class="tab-pane fade" id="sudoku" role="tabpanel">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <div class="d-flex align-items-center gap-2">
            <span class="text-muted">Complete o tabuleiro</span>
            <select id="sudokuLevel" class="form-select form-select-sm" style="width:auto">
              <option value="easy">F√°cil</option>
              <option value="medium">M√©dio</option>
              <option value="hard">Dif√≠cil</option>
            </select>
          </div>
          <div class="d-flex align-items-center gap-2">
            <span class="badge text-bg-secondary">Tempo: <span id="sudokuTimer">00:00</span></span>
            <span class="badge text-bg-info d-flex align-items-center gap-1">Vidas:
              <span id="sudokuLives" class="d-inline-flex align-items-center" aria-label="Vidas"></span>
            </span>
            <button class="btn btn-sm btn-primary" id="sudokuNew">Novo</button>
            <button class="btn btn-sm btn-outline-secondary" id="sudokuCheck">Verificar</button>
          </div>
        </div>
        <div id="sudokuGrid" class="d-grid" style="grid-template-columns: repeat(9, 1fr); gap: 4px; max-width: 420px;"></div>
        <div class="mt-2 small text-muted">Use n√∫meros 1-9. C√©lulas cinzas s√£o fixas. Erros consomem vidas, mas voc√™ pode continuar at√© elas acabarem.</div>
      </div>
    </div>
  </div>
  <div class="col-lg-4">
    <div class="card mb-3"><div class="card-body">
      <h5 class="card-title">Ranking Snake</h5>
      <ol id="snakeTop" class="mb-0"></ol>
    </div></div>
    <div class="card"><div class="card-body">
      <h5 class="card-title">Ranking Sudoku</h5>
      <ol id="sudokuTop" class="mb-0"></ol>
    </div></div>
  </div>
</div>
<script>
(function(){
  const top = (game, el) => {
    fetch(`/api/game/top?game=${encodeURIComponent(game)}`).then(r=>r.json()).then(d=>{
      if(!d||!d.ok) return; el.innerHTML='';
      d.items.forEach((it,i)=>{ const li=document.createElement('li'); li.textContent=`${i+1}. ${it.name} ‚Äî ${it.score}`; el.appendChild(li); });
      if(!d.items.length){ const li=document.createElement('li'); li.textContent='Sem registros'; el.appendChild(li); }
    }).catch(()=>{});
  };
  const snakeTop = document.getElementById('snakeTop');
  const sudokuTop = document.getElementById('sudokuTop');
  const refreshTops = () => { top('snake', snakeTop); top('sudoku', sudokuTop); };
  refreshTops(); setInterval(refreshTops, 20000);
})();
(function(){
  const canvas = document.getElementById('snakeCanvas'); if(!canvas) return;
  const ctx = canvas.getContext('2d');
  const w = 400, h = 400, size = 20; canvas.width=w; canvas.height=h;
  let snake, dir, food, score, timer, startAtMs=0, speed=120, alive=false;
  const rnd = (n)=>Math.floor(Math.random()*n);
  const placeFood = ()=>{ food = {x:rnd(w/size)*size, y:rnd(h/size)*size}; };
  const start = ()=>{ hideOverlay(); snake=[{x:200,y:200}]; dir={x:size,y:0}; score=0; updateScore(); placeFood(); startAtMs=Date.now(); speed=120; updateSpeed(); alive=true; loop(); canvas.focus(); };
  const reset = ()=>{ clearInterval(timer); ctx.clearRect(0,0,w,h); score=0; updateScore(); };
  const updateScore = ()=>{ document.getElementById('snakeScore').textContent=String(score); };
  const updateSpeed = ()=>{ document.getElementById('snakeSpeed').textContent = (Math.max(1, Math.round(240/speed))).toString() + 'x'; };
  const draw = ()=>{
    ctx.fillStyle='#0b132b'; ctx.fillRect(0,0,w,h);
    // grid
    ctx.strokeStyle='rgba(255,255,255,0.06)'; ctx.lineWidth=1;
    for(let i=0;i<=w;i+=size){ ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,h); ctx.stroke(); }
    for(let j=0;j<=h;j+=size){ ctx.beginPath(); ctx.moveTo(0,j); ctx.lineTo(w,j); ctx.stroke(); }
    ctx.fillStyle='#22c55e'; snake.forEach(p=>ctx.fillRect(p.x,p.y,size-2,size-2));
    ctx.fillStyle='#ef4444'; ctx.fillRect(food.x,food.y,size-2,size-2);
  };
  const step = ()=>{
    const head = {x:snake[0].x+dir.x, y:snake[0].y+dir.y};
    if(head.x<0||head.y<0||head.x>=w||head.y>=h||snake.some(s=>s.x===head.x&&s.y===head.y)){
      clearInterval(timer);
      alive=false;
      const ms = Math.max(0, Date.now()-startAtMs);
      fetch(`/api/game/score?game=snake&score=${encodeURIComponent(score)}&ms=${encodeURIComponent(ms)}`).finally(()=>{});
      showOverlay(score);
      return;
    }
    snake.unshift(head);
    if(head.x===food.x&&head.y===food.y){ score+=10; updateScore(); placeFood(); if(speed>60){ speed=Math.max(60, speed-4); updateSpeed(); loop(); } }
    else snake.pop();
    draw();
  };
  const loop = ()=>{ clearInterval(timer); draw(); timer=setInterval(step, speed); };
  const overlay = document.getElementById('snakeOverlay');
  const hideOverlay = ()=>{ overlay.classList.add('d-none'); };
  const showOverlay = (sc)=>{
    const msg = document.getElementById('snakeMsg');
    const end = document.getElementById('snakeFinal'); end.textContent = String(sc);
    let text = 'Fim de jogo!';
    if(sc < 50) text = 'Que pena! Cara, voc√™ √© p√©ssimo üòÇ';
    else if(sc < 100) text = 'Por pouco! Tente novamente.';
    else if(sc < 200) text = 'Boa! Voc√™ mandou bem!';
    else if(sc < 300) text = 'Excelente! Habilidade de cobra avan√ßada!';
    else text = 'Insano! Cobra lend√°ria!';
    msg.textContent = text;
    overlay.classList.remove('d-none');
  };
  document.getElementById('snakeStart').addEventListener('click', start);
  document.getElementById('snakeReset').addEventListener('click', reset);
  document.getElementById('snakeAgain').addEventListener('click', start);
  document.addEventListener('keydown', e=>{
    const onSnakeTab = document.getElementById('snake').classList.contains('active');
    if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key) && onSnakeTab){ e.preventDefault(); }
    if(!onSnakeTab || !alive) return;
    if(e.key==='ArrowUp' && dir.y===0) dir={x:0,y:-size};
    else if(e.key==='ArrowDown' && dir.y===0) dir={x:0,y:size};
    else if(e.key==='ArrowLeft' && dir.x===0) dir={x:-size,y:0};
    else if(e.key==='ArrowRight' && dir.x===0) dir={x:size,y:0};
  });
})();
(function(){
  const grid = document.getElementById('sudokuGrid'); if(!grid) return;
  let startTime = 0; let timerId = 0; let lives = 0; let maxLives=0; let currentSolved=null; let gameOver=false;
  // Sudoku generator/solver
  const clone = (b)=>b.map(r=>r.slice());
  const shuffle = (arr)=>{ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; };
  const findEmpty = (b)=>{ for(let r=0;r<9;r++){ for(let c=0;c<9;c++){ if(b[r][c]===0) return [r,c]; } } return null; };
  const isSafe = (b,r,c,v)=>{
    for(let i=0;i<9;i++){ if(b[r][i]===v||b[i][c]===v) return false; }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3; for(let i=0;i<3;i++){ for(let j=0;j<3;j++){ if(b[br+i][bc+j]===v) return false; }}
    return true;
  };
  const solve = (b, limit=1)=>{
    let solutions=0; const work=clone(b);
    const backtrack = ()=>{
      const pos=findEmpty(work); if(!pos){ solutions++; return solutions<limit; }
      const [r,c]=pos; const nums=shuffle([1,2,3,4,5,6,7,8,9]);
      for(const v of nums){ if(isSafe(work,r,c,v)){ work[r][c]=v; if(!backtrack()) return false; work[r][c]=0; } }
      return true;
    };
    backtrack();
    return solutions;
  };
  const generateSolved = ()=>{
    const board=[...Array(9)].map(()=>Array(9).fill(0));
    const fill = ()=>{
      const pos=findEmpty(board); if(!pos) return true;
      const [r,c]=pos; const nums=shuffle([1,2,3,4,5,6,7,8,9]);
      for(const v of nums){ if(isSafe(board,r,c,v)){ board[r][c]=v; if(fill()) return true; board[r][c]=0; } }
      return false;
    };
    fill();
    return board;
  };
  const generatePuzzle = (level)=>{
    const solved = generateSolved();
    const puzzle = clone(solved);
    // removals by level
    const removals = level==='hard'? 56 : level==='medium'? 50 : 40; // cells removed
    let removed = 0;
    const coords = [];
    for(let r=0;r<9;r++){ for(let c=0;c<9;c++){ coords.push([r,c]); }}
    shuffle(coords);
    for(const [r,c] of coords){ if(removed>=removals) break; const tmp=puzzle[r][c]; if(tmp===0) continue; puzzle[r][c]=0; // try remove
      // enforce unique solution
      const sol = solve(puzzle, 2); if(sol!==1){ puzzle[r][c]=tmp; } else { removed++; }
    }
    return { puzzle, solved };
  };
  const build = (puz)=>{
    const {puzzle, solved} = puz; grid.innerHTML=''; startTime=Date.now(); gameOver=false; currentSolved=solved; resetTimer(); startTimer();
    setLivesByLevel(); updateLives();
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const v = puzzle[r][c];
        const inp = document.createElement('input');
        inp.type='text'; inp.maxLength=1; inp.className='form-control text-center';
        inp.dataset.r=String(r); inp.dataset.c=String(c);
        if(v!==0){ inp.value=String(v); inp.disabled=true; inp.style.background='#f1f5f9'; }
        inp.addEventListener('input', (e)=>{
          if(gameOver) return;
          const t=e.target; const val=(t.value||'').replace(/[^1-9]/g,''); t.value=val; 
          // contabiliza erro contra solu√ß√£o
          const rr=+t.dataset.r, cc=+t.dataset.c; 
          if(val && currentSolved && Number(val)!==currentSolved[rr][cc]){
            // evitar penalizar repetidamente o mesmo erro
            const lastWrong = t.dataset.lastWrong||''; 
            if(lastWrong!==val){
              t.dataset.lastWrong = val;
              consumeLife();
            }
            t.classList.add('is-invalid');
          } else {
            t.dataset.lastWrong='';
          }
          updateConflicts();
        });
        inp.addEventListener('focus', ()=>{ updateConflicts(); });
        grid.appendChild(inp);
      }
    }
    updateConflicts();
  };
  const readBoard = ()=>{ const cells=grid.querySelectorAll('input'); const b=[...Array(9)].map(()=>Array(9).fill(0)); cells.forEach(inp=>{ const r=+inp.dataset.r, c=+inp.dataset.c; const v=Number(inp.value||0); b[r][c]= (inp.disabled? Number(inp.value) : (v>=1&&v<=9? v:0)); }); return b; };
  const completeNoConflicts = ()=>{ const b=readBoard(); for(let r=0;r<9;r++){ for(let c=0;c<9;c++){ if(b[r][c]===0) return false; if(!isSafe(b,r,c,b[r][c])) return false; }} return true; };
  const updateConflicts = ()=>{
    const b=readBoard();
    const cells=grid.querySelectorAll('input'); cells.forEach(i=>i.classList.remove('is-invalid'));
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const inp = grid.children[r*9+c]; if(inp.disabled) continue;
        const v=b[r][c]; if(!v) { inp.classList.remove('is-invalid'); continue; }
        // Temporarily clear to test safety strictly
        b[r][c]=0; const ok=isSafe(b,r,c,v); b[r][c]=v; if(!ok) inp.classList.add('is-invalid');
      }
    }
  };
  const newGame = ()=>{ const lvl=document.getElementById('sudokuLevel').value; build(generatePuzzle(lvl)); };
  const submitScore = ()=>{ const ms=Math.max(1, Date.now()-startTime); fetch(`/api/game/score?game=sudoku&score=1&ms=${encodeURIComponent(ms)}`).finally(()=>{}); };
  const setLivesByLevel = ()=>{ const lvl=document.getElementById('sudokuLevel').value; maxLives = (lvl==='easy')?5 : (lvl==='medium')?3 : 1; lives = maxLives; };
  const updateLives = ()=>{ const el=document.getElementById('sudokuLives'); if(!el) return; el.innerHTML='';
    for(let i=0;i<maxLives;i++){
      const ico=document.createElement('i');
      ico.className = 'bi ' + (i<lives ? 'bi-heart-fill text-danger' : 'bi-heart text-secondary');
      el.appendChild(ico);
    }
  };
  const consumeLife = ()=>{ lives = Math.max(0, lives-1); updateLives(); if(lives===0){ endGame(false, 'Suas vidas acabaram!'); } };
  const pad2 = (n)=> (n<10? '0'+n : String(n));
  const resetTimer = ()=>{ clearInterval(timerId); document.getElementById('sudokuTimer').textContent='00:00'; };
  const startTimer = ()=>{ clearInterval(timerId); timerId=setInterval(()=>{ const ms=Math.max(0, Date.now()-startTime); const s=Math.floor(ms/1000); const m=Math.floor(s/60); const ss=s%60; document.getElementById('sudokuTimer').textContent=pad2(m)+':'+pad2(ss); }, 500); };
  const stopTimer = ()=>{ clearInterval(timerId); };
  const endGame = (win, msg)=>{
    gameOver=true; stopTimer();
    const cells=grid.querySelectorAll('input'); cells.forEach(inp=>{ inp.disabled=true; });
    if(!win){ alert(msg||'Fim de jogo.'); }
  };
  document.getElementById('sudokuNew').addEventListener('click', newGame);
  document.getElementById('sudokuCheck').addEventListener('click', ()=>{ if(completeNoConflicts()){ submitScore(); endGame(true); alert('Parab√©ns! Sudoku completo.'); } else { alert('Ainda h√° conflitos ou c√©lulas vazias.'); } });
  newGame();
})();
</script>
{% endblock %}
